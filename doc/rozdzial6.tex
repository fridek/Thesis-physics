\chapter{Summary}
\label{cha:summary}

All four test were compiled and run times were measured on different platforms.

Unoptimised version of particle system (see: \ref{sec:particlesinitial}) was designed to perform a lot of memory operations. In tests it's visible that C++ handles this task best. Code generated using Emscripten benefits from static memory heap which effectively works similar to object pool introduced later and runs approximately twice as long as C++. Plain JavaScript suffers greatly from memory allocation issues and unoptimised code, resulting in 6 times slower execution than C++.

Optimised particles (see: \ref{sec:particlesobjectpool}) with object pool and low garbage collection show how improvements of algorithm result in much faster JavaScript execution. It still takes twice as long to run particle system in V8, but Emscripten version takes three times longer than C++. Additional overhead of long and complex code is clearly visible and since JS code employs the same techniques that Emscripten uses automatically, there is no improvement in related areas. It's worth mentioning that unoptimised version of C++ particle system is slightly slower than optimised JavaScript one, showing that code quality improvement that doesn't affect algorithmic complexity of algorithm may be more important than choice of environment.

\begin{table}[h!]
\caption{Particle tests on different platforms}
\label{table:benchmarks}
\begin{tabular}{|p{4cm}||l|l|l||l|l|l|}
  	\hline
   Platform & \multicolumn{3}{c}{Unoptimised particles} & \multicolumn{3}{c}{Optimised particles}\\ \hline
   & C++ & JavaScript & Emscripten & C++ & JavaScript & Emscripten\\ \hline
   Fedora 19, Intel i7 2670QM, 4GB RAM, g++ 4.8.1 & 3.21s & 19.51s & 4.85s & 1.63s & 4.96s & 5.10s \\ \hline
   Windows 7, Intel i7 2670QM, 4GB RAM, g++ 4.7.3, Cygwin & 3.51s & 20.77s & 6.46s & 1.71s & 3.47s & 5.57s \\ \hline
\end{tabular}
\end{table}

Sphere collision test is putting high load on CPU. 

In $O(n^2)$ version (see: \ref{sec:sphereinitial}) exactly 1 000 000 000 checks for object collisions are made. Overall execution time is surprisingly good for JavaScript with overhead of approximately 15\% and 25\% for Emscripten generated version. It's a result of putting focus on pure mathematical operations that are quickly compiled by V8 and processed on unboxed numbers in asm.js.

Space partitioning using Octree greatly reduces number of collisions (to less than 100 000) and execution time. To give meaningful results simulation time is increased from 1000 frames to 10000. Under these circumstances difference in run time changes to 20\% for Javascript and stays similarly around 25\% for Emscripten. This is result of small memory operations related to Octree areas.

\begin{table}[h!]
\caption{Spheres tests on different platforms}
\label{table:benchmarks}
\begin{tabular}{|p{4cm}||l|l|l||l|l|l|}
   \hline
   Platform & \multicolumn{3}{c}{$O(n^2)$ spheres} & \multicolumn{3}{c}{Octree spheres}\\ \hline
   & C++ & JavaScript & Emscripten & C++ & JavaScript & Emscripten\\ \hline
   Fedora 19, Intel i7 2670QM, 4GB RAM, g++ 4.8.1 & 4.96s & 9.02s & 12.35s & 
3.44s & 14.14s & 11.20s \\ \hline
   Windows 7, Intel i7 2670QM, 4GB RAM, g++ 4.7.3, Cygwin & 9.52s & 10.81s & 11.82s & 14.10s & 16.95s & 17.79s \\\hline
\end{tabular}
\end{table}

Above results show how well written JavaScript or properly converted C++ are able to perform in browser with similar performance as native programs, rarely exceeding 100\% overhead and sometimes getting as close as 15\% to C++ execution time. 

Conducted experiments show a gap between JavaScript and C++ performance. Significant language design differences result in code that is often easier to write but also easier to abuse. Benchmarks show differences between 15\% and 100\% overhead for correctly designed JavaScript code and over 500\% for incorrect patterns.  Considering Moore's law stating that computers double speed every 18 months it safe to say that JavaScript is very close to being suitable for any type of development.

Tests show clear pattern regarding dynamic variable types in JavaScript. Whenever boxing and unboxing happens, JIT compilation is not able to properly optimise code and bring it up to performance of C++. This affects both simple variables and properties end is especially visible for numbers. Transitions between integer and floats are expensive while easy to overlook.

Types affect significantly also method calls cost. Keeping methods monomorphic in core parts of physics engine is very important. Additional cost of polymorphism of parameters is not only boxing and unboxing of parameters but also time spent of optimising and deoptimising compiled method which makes initial warmup of engine longer. Exporting well defined methods to be called from polymorphic ones is an easy workaround for this performance bottleneck.

Lastly, memory management proven to be one of the most important problems in JavaScript. Automated garbage collection connected with popular pattern of creating and returning of arrays is an important problem. Memory allocation of objects is also a bottleneck, but not very dissimilar to one in C++. As shown in second version of particle system, usage of object pools and changing architecture to avoid array creation are techniques that can be employed to fight with it. It is worth mentioning that while garbage collection always introduces some overhead it is reasonable to avoid it at all costs. Sphere collision system with octree partitioning is also introducing and destroying objects, but overhead is significantly smaller than gained speedup. Advice for memory operations is to avoid objects living only for a single frame i.e. temporary variables and helpers. Long living objects are in general unavoidable and should be used whenever suitable.

General advice for programming in JavaScript is to use techniques similar to those found in asm.js - keep types static, method calls monomorphic and work carefully with memory.

Conducted tests show that while gap between JavaScript and native application exists and is not insignificant, there is a lot of potential in such approach. It is expected, that with growing community and interest from game industry new games will be released on browser within few years. Performance issues may prevent works on AAA titles, but companies focused more on social aspect of games and new trends in monetisation may create games targeted for different users. With capabilities of browsers equal to having 18 months older machine, less graphically demanding titles like The Sims or World or Warcraft may certainly be ported to run in JavaScript.

